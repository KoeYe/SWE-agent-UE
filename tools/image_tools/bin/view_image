#!/usr/bin/env python3
#!/usr/bin/env python3
# view_image – view an image file optimized for vLLM multimodal models
import base64
import mimetypes
import pathlib
import sys

VALID_MIME_TYPES = {
    "image/png",
    "image/jpeg", 
    "image/webp",
    "image/gif",
    "image/bmp"
}

# SWE-agent observation limit is 100,000 chars - leave more buffer for context window
# Reduce image size to allow for conversation history and other context
MAX_SAFE_OUTPUT = 30000

def compress_image_bytes(image_bytes: bytes, target_size: int = MAX_SAFE_OUTPUT) -> bytes:
    """Compress image bytes to fit within target base64 size using built-in libraries only"""
    
    # Calculate current base64 size (base64 encoding increases size by ~33%)
    current_b64_size = len(base64.b64encode(image_bytes))
    
    if current_b64_size <= target_size:
        return image_bytes
    
    # Try to use PIL/Pillow if available, otherwise return original with warning
    try:
        from PIL import Image
        import io
        
        # Open image from bytes
        img = Image.open(io.BytesIO(image_bytes))
        
        # Calculate scale factor to reduce size - more aggressive compression
        scale_factor = (target_size * 0.6 / current_b64_size) ** 0.5  # 60% target for safety
        new_width = int(img.size[0] * scale_factor)
        new_height = int(img.size[1] * scale_factor)
        
        if new_width > 0 and new_height > 0:
            # Resize image
            resized_img = img.resize((new_width, new_height), Image.Resampling.LANCZOS if hasattr(Image, 'Resampling') else Image.LANCZOS)
            
            # Convert to RGB if necessary for JPEG
            if resized_img.mode in ('RGBA', 'LA', 'P'):
                rgb_img = Image.new('RGB', resized_img.size, (255, 255, 255))
                if resized_img.mode == 'P':
                    resized_img = resized_img.convert('RGBA')
                if 'A' in resized_img.mode:
                    rgb_img.paste(resized_img, mask=resized_img.split()[-1])
                else:
                    rgb_img.paste(resized_img)
                resized_img = rgb_img
            
            # Save to bytes buffer as JPEG with moderate quality for better compression
            output_buffer = io.BytesIO()
            resized_img.save(output_buffer, format='JPEG', quality=70, optimize=True)
            compressed_bytes = output_buffer.getvalue()
            
            # Check if compression was effective
            compressed_b64_size = len(base64.b64encode(compressed_bytes))
            if compressed_b64_size <= target_size:
                return compressed_bytes
                
    except ImportError as e:
        print(e)
        print("# Warning: PIL not available, image may be large", file=sys.stderr)
    except Exception as e:
        print(f"# Warning: Could not compress image: {e}", file=sys.stderr)
    
    return image_bytes

if len(sys.argv) != 2:
    sys.exit(f"usage: {pathlib.Path(sys.argv[0]).name} <image-file>")

img_path = pathlib.Path(sys.argv[1])

if not img_path.exists():
    sys.exit(f"Error: File '{img_path}' does not exist")

if not img_path.is_file():
    sys.exit(f"Error: '{img_path}' is not a file")

try:
    mime = mimetypes.guess_type(img_path.name)[0]
    if mime not in VALID_MIME_TYPES:
        sys.exit(f"Error: Unsupported image type: {mime}. Valid types are: {', '.join(VALID_MIME_TYPES)}")

    # Read original image bytes
    original_bytes = img_path.read_bytes()
    original_size = len(original_bytes)
    
    # Compress if needed to fit within observation limits
    processed_bytes = compress_image_bytes(original_bytes)
    processed_size = len(processed_bytes)
    
    # Encode to base64
    b64 = base64.b64encode(processed_bytes).decode("ascii")
    
    # Print compression info to stderr if compressed
    if processed_size != original_size:
        print(f"# Compressed image: {original_size/1024:.1f}KB → {processed_size/1024:.1f}KB (base64: {len(b64):,} chars)", file=sys.stderr)
    else:
        print(f"# Image size: {original_size/1024:.1f}KB (base64: {len(b64):,} chars)", file=sys.stderr)
    
    # Output the base64 image in markdown format suitable for vLLM
    # Use JPEG mime type for compressed images 
    output_mime = "image/jpeg" if processed_size != original_size else mime
    print(f"![{img_path.as_posix()}](data:{output_mime};base64,{b64})")
    
except Exception as e:
    sys.exit(f"Error processing image: {e}")